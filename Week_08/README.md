## 学习笔记

#### LRU Cache

最近最少使用移除，简单的说就是最长时间没有使用的，当缓存满的时候会先清除这一个元素。关键点就在于大小的设置和替换策略，根据不同的替换策略产生
不同的替换的算法，比方说还有LFU等等。实现就是HashTable + 双向链表，实现可以自己手动来写数据结构来实现，也可以利用语言内置的数据结构来实现，
以Java为例，就用LinkedHashMap来实现，他的查询、删除、更新的时间复杂度都是O（1）的。更新原则就是最长时间没有使用的移除，不同的替换算法就是
更新原则不同

#### 排序

- 比较类排序（回见复杂度不能突破O(n * log n)）
    - 交换排序
        - 冒泡排序（O(n ^ 2)， 嵌套循环，每次将最大的元素放在数组末尾）
        - 快速排序（O(n * log n)， 取标杆，小元素放在标杆左侧，大元素放在标杆右侧，一次对左右进行快排）
    - 插入排序
        - 简单插入（O(n ^ 2)假设前面有序，从未排里面拿元素放到已排的里面去）
        - 希尔排序
    - 选择排序
        - 简单选择（O(n ^ 2), 找到最小值和未排数组头部交换）
        - 堆排序（O(n * log n)， 这个简单，直接使用语言已经实现的堆，不需要手动维护堆）
    - 归并排序（O(n * log n)， 分成子序列， 分别归并排序，然后合并）
        - 二路归并排序
        - 多路归并排序
- 非比较类排序
    - 计数排序
    - 桶排序
    - 基数排序



#### homework

作业链接 ：https://github.com/WangZhiLove/algorithm013/blob/master/Week_08/homework/README.md

每日一题链接 ： https://github.com/WangZhiLove/algorithm013/blob/master/OneQuestionPerDay/src/com/wz/september/readme.md

