## 每日一题的学习笔记

#### 1. 爬楼梯

这道题第一眼看去完全没有思路，没有一点解决方案，5分钟没有思路直接看题解：原来是斐波那契数列，于是脑海中有了解决方案

- 直接使用递归，简单直接明了，但是呢，时间复杂度是O（2^n）的，甚至超时了，吐了吐了
- 画出递归树，发现中间有很多重复的计算，所以使用记忆化递归，这次时间是快了，但是 leetcode 出现了内部出错，我咋这么难，继续下一个解决方案
- 动态规划：将中间的每一个值当做是一个状态，然后利用数组来计算每一个状态，前面的两个思路都是倒着计算，这次的动态规划就是正着来计算
- 斐波那契数列标准解法：与动态规划一样，只不过是减少了中间状态的记录，我们只要记录两个状态，一个是n-1，一个是n-2的状态就好,简化了空间复杂度
- 矩阵快速幂 - 大学学的还给老师了忘光了
- 通项公式 - 太难了，后面两个先不看吧，先不看吧，先不看吧

程序能实现的无非就是 for， while， loop， if， else， 递归；所以解题的关键在于寻找最小重复子单元。

第三遍： 很快，三种写法，也就15分钟。

#### 2. 加1

这道题第一眼看上去就有思路，相对于上面一个强了很多，并且单独写出来，写了两种思路，第一种思路直接被pass掉，非常规解法。第二种思路就接近标准题解了，
但是呢思路对了，写法还是有点问题，我利用了数据的拷贝，其实没有太大的必要，如果全部为9的话，其实就没有必要考虑其它位，直接新创建一个数组，长度为
原数组长度加一，将索引为0的置为1返回。

第二遍刷的话也就不到五分钟。

第三遍做，也就三四分钟吧，但是记住了最简单的写法，忘记了自己最开始的写法，也不知道是好还是坏。

#### 3. 两数之和

这个拿到题我脑海中就有了思路，和昨天做的那个盛水最多的容器一样，直接暴力求解，写出来了，没啥问题。然后要优化的话我暂时就没有思路了，能想到
要用一个去找另一个，但是没有想到利用哈希表这个结构，这个还是对数据结构不熟悉造成，如果能想到用哈希表，我应该会用两遍哈希的方法去解决这个问题，
题解中的一遍哈希是我没想到的，确实很优秀，代码简洁，我喜欢。继续加油！！！

第二遍，5分钟左右，基本搞定，还ok，继续加油，今天开始忙工作，所以做的时间晚了点。

第三遍做，基本没问题，两种思路都可以想出来，使用了简单的方法来写出代码，相对于以前的写法，代码行数增加了，但是更加的清晰明了，思路清晰了。

#### 4. 两两交换链表结点

这个题就算看了题解也没想通， 吐了吐了，递归的方法感觉理解起来更轻松，太难了，等会再看看，现在的思路比较乱，不想看，消息一下，一个小时都没写出来。
第二遍，使用递归思路，重复了一遍，没啥问题，继续加油。

第三遍提交，递归思路顺利写出来，没毛病，使用while循环的写法呢？虽然没写出来来，但是最大的收获是看懂了，想通了，下次肯定可以写出来！

#### 5. 合并两个有序链表

和昨天一样，仅仅有思路，代码写不出来，两种思路我都能想的出来，但是代码就是写不出来，气死我了气死我了，总结一下原因，写不出来的原因有两点：

1. Java基础不扎实，傻傻的引用分不清。
2. 递归运用不熟练，递归最终要的是什么，边界条件，返回值（其实我觉得写不出来的原因最终的还是第一点）

只能慢慢基础加油了，心酸的我，想哭器，有思路代码瞧不出来的感觉真难受。

明天第二遍就一定要两种思路都写出来！！！

第二遍没看前一天的，自己手写，虽然花费的时间稍微长点，但是没关系，自己写出来了就好，借鉴了昨天自己的缺点，今天认真思考下做出来，喜欢。

第三遍做: 感觉不好，在使用递归思路做的时候老是想想起以前的代码，导致影响了自己现在的思路，这个是不可取的，虽然有时候需要背，但是背的是写法，
而不是一模一样，这个需要注意，不过使用while循环的写法顺利写出来了，这个还算ok。

#### 6. 猜数字游戏

第一遍有思路，并且写出来，虽然代码比较啰嗦，但是思路是清晰的，还好。但是仅仅相想出了一个思路，然后看了外国友人的思路、题解，发现了更精妙的解法，
并且手动写了一遍，还不错，细节处理的很到位，哎，自己的路还有好多，继续加油。

第二遍刷，由于时间过的短点，所以很快就做出来，大概不到5分钟。

#### 7. 实现双端队列

其实这个实现有点投机取巧了，利用了已存在的链表实现，因为看下面的插入和移除操作比较多，所以使用链表来实现，当然也可以使用数组来实现，ArrayList等，
都可以这个是开放的，一次写出来，感觉还不错，能感觉到在进步，继续加油。

不过最近每天都是刷一道题，有点少了，并且视频也没有看，等会得补了，好多好多呀，homework也没写，总结也没写，头疼。

看了第四节课，哭了，基础不过关，竟然不知道LinkedList本身就是双端队列的实现，吐了，利用ArrayList来实现吧。其实还可以用数组来做，但是用数组的话
插入和删除的性能太差，如果要考虑性能好的数据结构，也就是插入和删除是O(1)的数据结构，自己来实现链表的结构也是可以实现的，我觉得性能会更好，这个大学
期间使用c++实现过，就用创建ListNode，然后把首尾链表实现出来就好。

#### 8. 数组的交集

求数组的交集，官方题解的两种思路和我想的都一样，差不多，并且代码写出来，这种感觉还不错，总共加上看题解，外国高票，大概四五十分钟吧，没卡时间。
但是这次拿上题就有思路的感觉真的很棒，这就是感觉吧。看了题解之后，犹豫了一下stream和for循环转变list到数组那个更快，发现后者更快，所以可以
考虑将stream刘转换换成for循环会更快。

第二遍做，一直在想最简单的写法，最优化的写法，不敢写脑中的第一个想法，其实已经是简单写法了，这个记录一下，犹豫是大计，过度优化也是不合理的。

#### 9. 删除最外层的括号

这道题拿到我是懵逼的，强行做出来。利用一个栈结构和双端队列，栈结构来判断对称，双端队列来存储元素，顺利解决，但是速度嘛不用说，慢。接下来说说
题解和外国友人的答案，计数器的解法，顾名思义，只需要使用一个计数器，就可以去掉最外层的括号，这个思路就比较神奇了，也不知道他们怎么想的，我咋就
想不到呢？服了，服了，不服不行，思路都想不出来，更不用说写代码了？看来自己还得磨炼呀。

第二遍提交删除最外层的括号，还不错，这写法，牛掰了，还得学习呀。

#### 10. 滑动窗口的最大值

这个题呢，我也自己做出来了，但是嘛执行效率就差了很多，看题解，题解的思路是在我旧的的思路上做了优化，我的思路是利用一个数组和一个最大值来处理，
题解多加了一个最大值的索引，然后在循环的时候就可以判断最大值的索引是否还在滑动窗口索引内，也就是最大值的索引必须大于循环的i，第一次的话会执行
k次来获取第一个窗口的最大值和索引值，之后移动的时候就可以判断最大索引是否在循环的i处，如果不在，就重新获取当前滑动窗口的最大值和对应的索引。

外国友人的思路和这个一样，仅仅思路一样，代码借用了双端队列，双端队列的队首元素一直是在滑动窗口内的最大值，有两种情况弹出，一种是队首元素的索引
不在滑动窗口内，弹出，另一种就是队首元素小了，弹出。每次循环，都入队当前的元素索引。**这里给了一个思路，以后如果要对比数组的元素，可以利用索引，
不一定非要使用数组元素**。中间的比对用循环来对比，因为每次都会入队新的元素。这个思路我觉得很好，利用了合适的数据结构，真的很不错。

第二遍提交滑动窗口的最大值，抛弃自己拿丑陋的写法，就写两种代码简洁的写法。继续加油。

#### 11. FizzBuzz

这个可以说做题以来最简单的一道题了，顺利写出来了，看了外国友人的，一个不使用 % 的做法，就是计数法，声明两个变量，循环 + 1， 遇到3，一个置0，
遇到五，另一个置0，一个3一个5同时置0，这个思路倒是很有意思。官方的字符串拼接的思路也还可以，总之我只想到了一种思路，看看别人的思路还是不错的。

第二遍提交，没有使用 % ， 顺利做出来

#### 12. 各位相加

这道题真的是智商税了，但是有一点是我的错，就是再取一个数字的每一位的时候，我使用了先转字符串，然后取每一位，怎么没想到取余和除呢，这个是我的问题，
O(1)想法没想出来这个还可以说是没想到，不过找最近重复单元这点还是没学到，厉害了。学到学到了。

第二遍做，顺利做出来，还不错，两种写法都写出来，不过写第二遍利用递归的时候再次考虑了下时间复杂度，感觉时间复杂度有点问题，重新分析了下，应该是
O(n)！！！