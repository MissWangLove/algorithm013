## 每日一题的学习笔记

#### 1. 爬楼梯

这道题第一眼看去完全没有思路，没有一点解决方案，5分钟没有思路直接看题解：原来是斐波那契数列，于是脑海中有了解决方案

- 直接使用递归，简单直接明了，但是呢，时间复杂度是O（2^n）的，甚至超时了，吐了吐了
- 画出递归树，发现中间有很多重复的计算，所以使用记忆化递归，这次时间是快了，但是 leetcode 出现了内部出错，我咋这么难，继续下一个解决方案
- 动态规划：将中间的每一个值当做是一个状态，然后利用数组来计算每一个状态，前面的两个思路都是倒着计算，这次的动态规划就是正着来计算
- 斐波那契数列标准解法：与动态规划一样，只不过是减少了中间状态的记录，我们只要记录两个状态，一个是n-1，一个是n-2的状态就好,简化了空间复杂度
- 矩阵快速幂 - 大学学的还给老师了忘光了
- 通项公式 - 太难了，后面两个先不看吧，先不看吧，先不看吧

程序能实现的无非就是 for， while， loop， if， else， 递归；所以解题的关键在于寻找最小重复子单元。

第三遍： 很快，三种写法，也就15分钟。

#### 2. 加1

这道题第一眼看上去就有思路，相对于上面一个强了很多，并且单独写出来，写了两种思路，第一种思路直接被pass掉，非常规解法。第二种思路就接近标准题解了，
但是呢思路对了，写法还是有点问题，我利用了数据的拷贝，其实没有太大的必要，如果全部为9的话，其实就没有必要考虑其它位，直接新创建一个数组，长度为
原数组长度加一，将索引为0的置为1返回。

第二遍刷的话也就不到五分钟。

第三遍做，也就三四分钟吧，但是记住了最简单的写法，忘记了自己最开始的写法，也不知道是好还是坏。

#### 3. 两数之和

这个拿到题我脑海中就有了思路，和昨天做的那个盛水最多的容器一样，直接暴力求解，写出来了，没啥问题。然后要优化的话我暂时就没有思路了，能想到
要用一个去找另一个，但是没有想到利用哈希表这个结构，这个还是对数据结构不熟悉造成，如果能想到用哈希表，我应该会用两遍哈希的方法去解决这个问题，
题解中的一遍哈希是我没想到的，确实很优秀，代码简洁，我喜欢。继续加油！！！

第二遍，5分钟左右，基本搞定，还ok，继续加油，今天开始忙工作，所以做的时间晚了点。

第三遍做，基本没问题，两种思路都可以想出来，使用了简单的方法来写出代码，相对于以前的写法，代码行数增加了，但是更加的清晰明了，思路清晰了。

#### 4. 两两交换链表结点

这个题就算看了题解也没想通， 吐了吐了，递归的方法感觉理解起来更轻松，太难了，等会再看看，现在的思路比较乱，不想看，消息一下，一个小时都没写出来。
第二遍，使用递归思路，重复了一遍，没啥问题，继续加油。

第三遍提交，递归思路顺利写出来，没毛病，使用while循环的写法呢？虽然没写出来来，但是最大的收获是看懂了，想通了，下次肯定可以写出来！

#### 5. 合并两个有序链表

和昨天一样，仅仅有思路，代码写不出来，两种思路我都能想的出来，但是代码就是写不出来，气死我了气死我了，总结一下原因，写不出来的原因有两点：

1. Java基础不扎实，傻傻的引用分不清。
2. 递归运用不熟练，递归最终要的是什么，边界条件，返回值（其实我觉得写不出来的原因最终的还是第一点）

只能慢慢基础加油了，心酸的我，想哭器，有思路代码瞧不出来的感觉真难受。

明天第二遍就一定要两种思路都写出来！！！

第二遍没看前一天的，自己手写，虽然花费的时间稍微长点，但是没关系，自己写出来了就好，借鉴了昨天自己的缺点，今天认真思考下做出来，喜欢。

第三遍做: 感觉不好，在使用递归思路做的时候老是想想起以前的代码，导致影响了自己现在的思路，这个是不可取的，虽然有时候需要背，但是背的是写法，
而不是一模一样，这个需要注意，不过使用while循环的写法顺利写出来了，这个还算ok。

#### 6. 猜数字游戏

第一遍有思路，并且写出来，虽然代码比较啰嗦，但是思路是清晰的，还好。但是仅仅相想出了一个思路，然后看了外国友人的思路、题解，发现了更精妙的解法，
并且手动写了一遍，还不错，细节处理的很到位，哎，自己的路还有好多，继续加油。

第二遍刷，由于时间过的短点，所以很快就做出来，大概不到5分钟。

第三遍做的时候可以说是没有思路，但是自己做出来了，不敢相信，用了简单的方法，但是遗忘了自己复杂的写法，哭泣，不过还好，只记住简单的方法也好。

#### 7. 实现双端队列

其实这个实现有点投机取巧了，利用了已存在的链表实现，因为看下面的插入和移除操作比较多，所以使用链表来实现，当然也可以使用数组来实现，ArrayList等，
都可以这个是开放的，一次写出来，感觉还不错，能感觉到在进步，继续加油。

不过最近每天都是刷一道题，有点少了，并且视频也没有看，等会得补了，好多好多呀，homework也没写，总结也没写，头疼。

看了第四节课，哭了，基础不过关，竟然不知道LinkedList本身就是双端队列的实现，吐了，利用ArrayList来实现吧。其实还可以用数组来做，但是用数组的话
插入和删除的性能太差，如果要考虑性能好的数据结构，也就是插入和删除是O(1)的数据结构，自己来实现链表的结构也是可以实现的，我觉得性能会更好，这个大学
期间使用c++实现过，就用创建ListNode，然后把首尾链表实现出来就好。

#### 8. 数组的交集

求数组的交集，官方题解的两种思路和我想的都一样，差不多，并且代码写出来，这种感觉还不错，总共加上看题解，外国高票，大概四五十分钟吧，没卡时间。
但是这次拿上题就有思路的感觉真的很棒，这就是感觉吧。看了题解之后，犹豫了一下stream和for循环转变list到数组那个更快，发现后者更快，所以可以
考虑将stream刘转换换成for循环会更快。

第二遍做，一直在想最简单的写法，最优化的写法，不敢写脑中的第一个想法，其实已经是简单写法了，这个记录一下，犹豫是大计，过度优化也是不合理的。

第三遍做，有些遗忘，但是还好，稍微提醒一下就可以了，记住，不要用连续的if，记得使用if-else if

#### 9. 删除最外层的括号

这道题拿到我是懵逼的，强行做出来。利用一个栈结构和双端队列，栈结构来判断对称，双端队列来存储元素，顺利解决，但是速度嘛不用说，慢。接下来说说
题解和外国友人的答案，计数器的解法，顾名思义，只需要使用一个计数器，就可以去掉最外层的括号，这个思路就比较神奇了，也不知道他们怎么想的，我咋就
想不到呢？服了，服了，不服不行，思路都想不出来，更不用说写代码了？看来自己还得磨炼呀。

第二遍提交删除最外层的括号，还不错，这写法，牛掰了，还得学习呀。

第三遍提交，有点遗忘了，不过稍微看下就能想起来，不用从头梳理思路。

#### 10. 滑动窗口的最大值

这个题呢，我也自己做出来了，但是嘛执行效率就差了很多，看题解，题解的思路是在我旧的的思路上做了优化，我的思路是利用一个数组和一个最大值来处理，
题解多加了一个最大值的索引，然后在循环的时候就可以判断最大值的索引是否还在滑动窗口索引内，也就是最大值的索引必须大于循环的i，第一次的话会执行
k次来获取第一个窗口的最大值和索引值，之后移动的时候就可以判断最大索引是否在循环的i处，如果不在，就重新获取当前滑动窗口的最大值和对应的索引。

外国友人的思路和这个一样，仅仅思路一样，代码借用了双端队列，双端队列的队首元素一直是在滑动窗口内的最大值，有两种情况弹出，一种是队首元素的索引
不在滑动窗口内，弹出，另一种就是队首元素小了，弹出。每次循环，都入队当前的元素索引。**这里给了一个思路，以后如果要对比数组的元素，可以利用索引，
不一定非要使用数组元素**。中间的比对用循环来对比，因为每次都会入队新的元素。这个思路我觉得很好，利用了合适的数据结构，真的很不错。

第二遍提交滑动窗口的最大值，抛弃自己拿丑陋的写法，就写两种代码简洁的写法。继续加油。

第三遍提交，忘记了使用最大值和最大值的索引进行判断的方法，写出了双端队列的写法，看来还得常练。忘记了忘记了难受。

#### 11. FizzBuzz

这个可以说做题以来最简单的一道题了，顺利写出来了，看了外国友人的，一个不使用 % 的做法，就是计数法，声明两个变量，循环 + 1， 遇到3，一个置0，
遇到五，另一个置0，一个3一个5同时置0，这个思路倒是很有意思。官方的字符串拼接的思路也还可以，总之我只想到了一种思路，看看别人的思路还是不错的。

第二遍提交，没有使用 % ， 顺利做出来

第三遍做，两种思路都很清晰，用了取余的方案顺利做出来

#### 12. 各位相加

这道题真的是智商税了，但是有一点是我的错，就是再取一个数字的每一位的时候，我使用了先转字符串，然后取每一位，怎么没想到取余和除呢，这个是我的问题，
O(1)想法没想出来这个还可以说是没想到，不过找最近重复单元这点还是没学到，厉害了。学到学到了。

第二遍做，顺利做出来，还不错，两种写法都写出来，不过写第二遍利用递归的时候再次考虑了下时间复杂度，感觉时间复杂度有点问题，重新分析了下，应该是
O(n)！！！

第三遍做，顺利做出来了，但是时间复杂度又懵了，感觉时间复杂度又变成 O(2^n).

#### 13. 树的中序遍历

左-根-右，这个我没做出来，认真的反思了下自己，发现是思路不是很对，一直在纠结怎么放左右结点，其实无论是左右结点，本质都可以看作是根节点，所以只
需要考虑什么时候存放根节点就ok。

第二遍做，脑子抽住了，哎，递归的时候顺手写了个while循环，也不知道自己咋想的，看下周的第三遍咋样。

第三次提交二叉树的中序遍历。还不错，很快就做下来了，自我感觉进步很大。

#### 14. N叉树的后续遍历

利用递归自己做出来了，使用迭代还是看了题解，说明这里还是不熟悉呀，继续加油。

第二遍做，很顺利，还不错。

递归写法没问题，迭代又忘记了，不过没事，多记几遍就好。

#### 15. 剑指offer - 40 最小的k个数

使用了先排序，后取值的思路，至于堆的那种解法可以当做堆的练习吧，还是感觉先排序这个更加简单和高效。

#### 16. 第一遍提交替换空格

这个利用了两种方法，顺利完成，结果还不错，但是这道题有点简单了，再做一道昨天的那个堆的题目，就是高频k的那个题，做做看看。

15和16不用重复第二和第三遍

#### 17. 前k个高频元素

这个题本来昨天做的，结果昨天有点忘，就没走，今天补上，一会在看看视频，做做这周的homework。

第二遍做，才知道自己第一遍都做错了，但是抄对了，在建大顶堆的时候出错了，后面用了错误的比较器，但是现在也没想通为啥大顶堆要用升序，这个还得琢磨下

第三遍做，很顺利的完成了，还算可以，没出大的问题，除了几个粗心的问题，不影响操作，继续，今天才复习了一个题。

#### 18. 二叉树的最近公共祖先

这道题难住我了，这个递归看得我懵皮的不行，递归还是没学到位，做完一遍其实理解还是不到位，明天再做一遍看看。外国友人的四行代码惊呆我了，我了个去。
牛掰了，mmp。不过就是太难理解了，看了半天也没看懂，难受。

第二遍做，两种写法都写出来，这种感觉真的好舒服，就是做第三遍的时候不知道还能不能这么舒服。

第三遍实现，发现有点遗忘了，写出来了百分之九十，在做的时候一直考虑的是root的左右节点，还是没有适应递归这种解法，尤其在递归的时候返回左右节点就
更懵皮了，不过没事，记住就好，加油加油

#### 19. 实现pow(x, n)，即计算 x 的 n 次幂函数。

这道题我想用暴力求解，循环 n 次，难在了两点，都体现在题目中。看了题解才发现原来分治的思路是这样的，学到了，不过，我觉得我应该练习练习递归的题，
因为我发现我的递归还不到家，更不要说分治和回溯了。

第二遍做，使用了递归，但是我发现我不会分析递归的时间复杂度和空间复杂度，这个就很尴尬了，再琢磨琢磨。

#### 20. 验证二叉搜索树
 
自己利用中序遍历是做出来，但是过程曲折，第一次想用递归，结果思路错误。第二次使用中序遍历，写法有问题，但是算是做出来，继续加油。

第一遍是有思路，但是写法也有问题，第二遍就很快做出来。

#### 21. 二叉树的最大深度

这道题做不出来是我的问题，因为今天心烦躁的，没有那个劲头做题，勉强做下来，效果不好，今天就先到这，以后不能这样了。

第二遍做，很快，还不错。但是是因为这道题比较简单。

#### 22. 组合

第一次做组合，没有思路，对于回溯法的代码完全不理解，看不懂呀，不过第一遍算是看下来，看了大概20分钟，总算看懂写下来了。

第二遍做，顺利做出来，算是背下代码，后面如何就得看下周了。

#### 23. 全排列

这个是我第一次独立做出来，虽然做出来了，但是还是有点迷，其实十几分钟二十几分钟没做出来就看了题解，但是看着太复杂，看不懂，于是自己独立想，想到了
拷贝集合的方式来做，还不错，独立做出来的感觉很棒。

这个我记住了，还不错，顺利的完成并写下来了，还算ok，没出大的问题。

#### 24. 最小基因变化

这道题拿上就没有思路，首先看题目理解了半天，之后看懂题意之后开始思考解决方案，也过发现没有思路，这个只能一个一个试了，那这种试的解决方案就是回溯。
这才是回溯的定义所在把，于是看了题解，题解看了半天才理解，总之觉得这个不好想，不好做，比较难。还得练，不过最近两天做的都是bfs的，dfs的我还没有
试过，这周末得总结了一下dfs和bfs的代码模版，把树相关的题目都总结一下。

第二遍做，也顺利做下来了，基本没有卡壳，虽然花的时间久点，但这是因为这道题的代码本身比较复杂，只要有思路，知道使用什么数据结构或者方法来解决类似
的问题，基本就没有难度。

#### 25. 柠檬水找零

刚拿到手就有思路，然后使用map做了一下，结果显而易见，效率很差，虽然相同的思路，然后想优化方案，能不能用个数来判断，写出来，错误，因为是有先后顺
序的，所以又想，到了午休时间，休息一会，然后趴那的时候想了一下，可以直接使用计数的方法，没有必要使用map数据结构，于是睡觉起来顺利写出来，还不错。
继续加油。